/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  getU8Encoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedBurnInstruction,
  type ParsedCloseRateAccountInstruction,
  type ParsedCreateRateAccountInstruction,
  type ParsedFreezeInstruction,
  type ParsedInitializeMintInstruction,
  type ParsedInitializeVerificationConfigInstruction,
  type ParsedMintInstruction,
  type ParsedPauseInstruction,
  type ParsedResumeInstruction,
  type ParsedSplitInstruction,
  type ParsedThawInstruction,
  type ParsedTrimVerificationConfigInstruction,
  type ParsedUpdateMetadataInstruction,
  type ParsedUpdateRateAccountInstruction,
  type ParsedUpdateVerificationConfigInstruction,
  type ParsedVerifyInstruction,
} from '../instructions';

export const SECURITY_TOKEN_PROGRAM_PROGRAM_ADDRESS =
  'Gwbvvf4L2BWdboD1fT7Ax6JrgVCKv5CN6MqkwsEhjRdH' as Address<'Gwbvvf4L2BWdboD1fT7Ax6JrgVCKv5CN6MqkwsEhjRdH'>;

export enum SecurityTokenProgramAccount {
  MintAuthority,
  Rate,
  Receipt,
  VerificationConfig,
}

export enum SecurityTokenProgramInstruction {
  InitializeMint,
  UpdateMetadata,
  InitializeVerificationConfig,
  UpdateVerificationConfig,
  TrimVerificationConfig,
  Verify,
  Mint,
  Burn,
  Pause,
  Resume,
  Freeze,
  Thaw,
  CreateRateAccount,
  UpdateRateAccount,
  CloseRateAccount,
  Split,
}

export function identifySecurityTokenProgramInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): SecurityTokenProgramInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (containsBytes(data, getU8Encoder().encode(0), 0)) {
    return SecurityTokenProgramInstruction.InitializeMint;
  }
  if (containsBytes(data, getU8Encoder().encode(1), 0)) {
    return SecurityTokenProgramInstruction.UpdateMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(2), 0)) {
    return SecurityTokenProgramInstruction.InitializeVerificationConfig;
  }
  if (containsBytes(data, getU8Encoder().encode(3), 0)) {
    return SecurityTokenProgramInstruction.UpdateVerificationConfig;
  }
  if (containsBytes(data, getU8Encoder().encode(4), 0)) {
    return SecurityTokenProgramInstruction.TrimVerificationConfig;
  }
  if (containsBytes(data, getU8Encoder().encode(5), 0)) {
    return SecurityTokenProgramInstruction.Verify;
  }
  if (containsBytes(data, getU8Encoder().encode(6), 0)) {
    return SecurityTokenProgramInstruction.Mint;
  }
  if (containsBytes(data, getU8Encoder().encode(7), 0)) {
    return SecurityTokenProgramInstruction.Burn;
  }
  if (containsBytes(data, getU8Encoder().encode(8), 0)) {
    return SecurityTokenProgramInstruction.Pause;
  }
  if (containsBytes(data, getU8Encoder().encode(9), 0)) {
    return SecurityTokenProgramInstruction.Resume;
  }
  if (containsBytes(data, getU8Encoder().encode(10), 0)) {
    return SecurityTokenProgramInstruction.Freeze;
  }
  if (containsBytes(data, getU8Encoder().encode(11), 0)) {
    return SecurityTokenProgramInstruction.Thaw;
  }
  if (containsBytes(data, getU8Encoder().encode(12), 0)) {
    return SecurityTokenProgramInstruction.CreateRateAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(13), 0)) {
    return SecurityTokenProgramInstruction.UpdateRateAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(14), 0)) {
    return SecurityTokenProgramInstruction.CloseRateAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(15), 0)) {
    return SecurityTokenProgramInstruction.Split;
  }
  throw new Error(
    'The provided instruction could not be identified as a securityTokenProgram instruction.'
  );
}

export type ParsedSecurityTokenProgramInstruction<
  TProgram extends string = 'Gwbvvf4L2BWdboD1fT7Ax6JrgVCKv5CN6MqkwsEhjRdH',
> =
  | ({
      instructionType: SecurityTokenProgramInstruction.InitializeMint;
    } & ParsedInitializeMintInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.UpdateMetadata;
    } & ParsedUpdateMetadataInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.InitializeVerificationConfig;
    } & ParsedInitializeVerificationConfigInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.UpdateVerificationConfig;
    } & ParsedUpdateVerificationConfigInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.TrimVerificationConfig;
    } & ParsedTrimVerificationConfigInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Verify;
    } & ParsedVerifyInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Mint;
    } & ParsedMintInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Burn;
    } & ParsedBurnInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Pause;
    } & ParsedPauseInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Resume;
    } & ParsedResumeInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Freeze;
    } & ParsedFreezeInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Thaw;
    } & ParsedThawInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.CreateRateAccount;
    } & ParsedCreateRateAccountInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.UpdateRateAccount;
    } & ParsedUpdateRateAccountInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.CloseRateAccount;
    } & ParsedCloseRateAccountInstruction<TProgram>)
  | ({
      instructionType: SecurityTokenProgramInstruction.Split;
    } & ParsedSplitInstruction<TProgram>);
